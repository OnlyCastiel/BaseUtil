package com.train.leetcode;

import java.util.Arrays;

public class SortTrain {

    //第一大类：插入排序
    /**
     * 一、插入排序的基本思想是：每一趟将一个待排序的记录，按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。
     * 例如，打扑克牌在抓牌时要保证抓过的牌有序排列，则每抓一张牌，就插入到合适的位置，直到抓完牌为止，即可得到一个有序序列。
     * 可以选择不同的方法在已排好序的记录中寻找插入位置。根据查找方法的不同，有多种插入排序方法，这里仅介绍三种方法：直接插入排序、折半插入排序和希尔排序。
     *
     * 直接插入排序（Straight Insertion Sort）是一种最简单的排序方法，
     * 其基本操作是将一条记录插入到已排好序的有序表中，从而得到一个新的、记录数量增1的有序表。
     * 时间复杂度为O(n2)  空间复杂度为O(1)
     *
     * 二、折半插入排序
     * 直接插入排序采用顺序查找法查找当前记录在已排好序的序列中的插入位置，
     * 从7.2节的讨论中可知，这个“查找”操作可利用“折半查找”来实现，
     * 由此进行的插入排序称之为折半插入排序（Binary Insertion Sort）。
     * 时间复杂度仍为O(n2)    O(1)
     *
     *
     *
     * 三、希尔排序（Shell's Sort）又称“缩小增量排序”（Diminishing IncrementSort），是插入排序的一种，因D.L.Shell于1959年提出而得名。
     *
     * 希尔排序实质上是采用分组插入的方法。先将整个待排序记录序列分割成几组，从而减少参与直接插入排序的数据量，
     * 对每组分别进行直接插入排序，然后增加每组的数据量，重新分组。这样当经过几次分组排序后，整个序列中的记录“基本有序”时，
     * 再对全体记录进行一次直接插入排序。希尔对记录的分组，不是简单地“逐段分割”，而是将相隔某个“增量”的记录分成一组。
     *
     * ① 第一趟取增量d1（d1<n）把全部记录分成d1个组，所有间隔为d1的记录分在同一组，在各个组中进行直接插入排序。
     * ② 第二趟取增量d2（d2<d1），重复上述的分组和排序。
     * ③ 依次类推，直到所取的增量dt=1（dt<dt−1 <…< d2 < d1），所有记录在同一组中进行直接插入排序为止。
     *
     * 例如：10个元素，
     * 第一趟取增量5；则为0-5、1-6、2-7、3-8、4-9进行比较交换
     * 第二趟取增量3：取0-3-6、1-4-7、2-5-8进行比较
     * 第三趟取增量1：对整个序列进行一趟直接插入排序，排序完成
     *
     * 基本思想：在插入排序基础上，进行优化，避免直接进行插入排序时，移动元素位数过多
     */



    //第二大类：交换排序
    /**
     * 交换排序的基本思想是：两两比较待排序记录的关键字，一旦发现两个记录不满足次序要求时则进行交换，直到整个序列全部满足要求为止。
     * 本节首先介绍基于简单交换思想实现的冒泡排序，然后给出另一种在此基础上进行改进的排序方法——快速排序。
     *
     * 一、冒泡排序
     * 冒泡排序（Bubble Sort）是一种最简单的交换排序方法，它通过两两比较相邻记录的关键字，如果发生逆序，则进行交换，
     * 从而使关键字小的记录如气泡一般逐渐往上“漂浮”（左移），或者使关键字大的记录如石块一样逐渐向下“坠落”（右移）。
     * 时间复杂度为O(n2)  空间复杂度为O(1)
     *
     * 二、快速排序
     * 快速排序（Quick Sort）是由冒泡排序改进而得的。在冒泡排序过程中，只对相邻的两个记录进行比较，因此每次交换两个相邻记录时只能消除一个逆序。
     * 如果能通过两个（不相邻）记录的一次交换，消除多个逆序，则会大大加快排序的速度。快速排序方法中的一次交换可能消除多个逆序。
     *
     * 在待排序的n个记录中任取一个记录（通常取第一个记录）作为枢轴（或支点），设其关键字为pivotkey。
     * 经过一趟排序后，把所有关键字小于pivotkey的记录交换到前面，把所有关键字大于pivotkey的记录交换到后面，
     * 结果将待排序记录分成两个子表，最后将枢轴放置在分界处的位置。然后，分别对左、右子表重复上述过程，直至每一子表只有一个记录时，排序完成。
     *
     *
     */

    //二分插入排序

    /**
     * 快速排序:平均时间复杂度 O（nlog n）  最差情况 O（n*n）
     * log n 为确定轴的次数 ， 例如N=8，第一次确定1个轴，第二次确定2个轴，第三次确定3个轴；完成
     * 最差情况，每次确定轴，数据都在一边，则要确定八次轴；
     *
     * 引入轴的概念，选定一个元素为基准数，将所有小于该数的元素放在左边，大于该数的元素放在右边；该数在数组中最后位置便确定了
     * 对每一个分区，继续选定基准数，移动其他元素分列左右两边
     * 递归重复上述步骤，一直到分区的长度等于1或0;
     */
    public static void quickSort(int[] nums,int start,int end){
        if(end == start){
            return;
        }
        //基准取中间值，也可使用首位，或使用随机位置；
        int base = nums[start + end >> 1];
        int left = start;
        int right = end;
        while (left < right){
            while (nums[left] <= base && left <right){
                left ++;
            }
            while (nums[right] >= base && left <right){
                right --;
            }
            if(left < right){
                swap(nums,left,right);
            }
        }
        System.out.println(left + "" + right);
        swap(nums,left-1,start + end >> 1);
        //quickSort(nums,start,left);
        //quickSort(nums,left,end);
        return;
    }

    public static void swap(int[] nums,int x,int y){
        int temp = nums[x];
        nums[x] = nums[y];
        nums[y] = temp;
    }


    /**
     * 我们可以用快速排序来解决这个问题，先对原数组排序，再返回倒数第 kk 个位置，这样平均时间复杂度是 O(n \log n)O(nlogn)，但其实我们可以做的更快。
     *
     * 首先我们来回顾一下快速排序，这是一个典型的分治算法。我们对数组 a[l \cdots r]a[l⋯r] 做快速排序的过程是（参考《算法导论》）：
     *
     * 分解： 将数组 a[l \cdots r]a[l⋯r] 「划分」成两个子数组 a[l \cdots q - 1]a[l⋯q−1]、a[q + 1 \cdots r]a[q+1⋯r]，使得 a[l \cdots q - 1]a[l⋯q−1] 中的每个元素小于等于 a[q]a[q]，且 a[q]a[q] 小于等于 a[q + 1 \cdots r]a[q+1⋯r] 中的每个元素。其中，计算下标 qq 也是「划分」过程的一部分。
     * 解决： 通过递归调用快速排序，对子数组 a[l \cdots q - 1]a[l⋯q−1] 和 a[q + 1 \cdots r]a[q+1⋯r] 进行排序。
     * 合并： 因为子数组都是原址排序的，所以不需要进行合并操作，a[l \cdots r]a[l⋯r] 已经有序。
     * 上文中提到的 「划分」 过程是：从子数组 a[l \cdots r]a[l⋯r] 中选择任意一个元素 xx 作为主元，调整子数组的元素使得左边的元素都小于等于它，右边的元素都大于等于它， xx 的最终位置就是 qq。
     * 由此可以发现每次经过「划分」操作后，我们一定可以确定一个元素的最终位置，即 xx 的最终位置为 qq，并且保证 a[l \cdots q - 1]a[l⋯q−1] 中的每个元素小于等于 a[q]a[q]，且 a[q]a[q] 小于等于 a[q + 1 \cdots r]a[q+1⋯r] 中的每个元素。所以只要某次划分的 qq 为倒数第 kk 个下标的时候，我们就已经找到了答案。 我们只关心这一点，至于 a[l \cdots q - 1]a[l⋯q−1] 和 a[q+1 \cdots r]a[q+1⋯r] 是否是有序的，我们不关心。
     *
     * 因此我们可以改进快速排序算法来解决这个问题：在分解的过程当中，我们会对子数组进行划分，如果划分得到的 qq 正好就是我们需要的下标，就直接返回 a[q]a[q]；否则，如果 qq 比目标下标小，就递归右子区间，否则递归左子区间。这样就可以把原来递归两个区间变成只递归一个区间，提高了时间效率。这就是「快速选择」算法。
     *
     * 我们知道快速排序的性能和「划分」出的子数组的长度密切相关。直观地理解如果每次规模为 nn 的问题我们都划分成 11 和 n - 1n−1，每次递归的时候又向 n - 1n−1 的集合中递归，这种情况是最坏的，时间代价是 O(n ^ 2)O(n
     * 2
     *  )。我们可以引入随机化来加速这个过程，它的时间代价的期望是 O(n)O(n)，证明过程可以参考「《算法导论》9.2：期望为线性的选择算法」。
     * @param args
     */

    public static void main(String[] args) {
        //System.out.println(10+2 >> 1);

        int[] a = {4,2,3,5,1,2,5,6};

        //int[] a = {4,2};
        quickSort(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }



}
